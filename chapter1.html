<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>第1章：扩散模型导论 - Diffusion Models Tutorial</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.8;
            color: #333;
            background-color: #f5f5f5;
            padding: 20px;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        
        h2 {
            color: #34495e;
            margin-top: 40px;
            margin-bottom: 20px;
            font-size: 1.8em;
        }
        
        h3 {
            color: #34495e;
            margin-top: 30px;
            margin-bottom: 15px;
            font-size: 1.4em;
        }
        
        p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        .nav-bar {
            background-color: #ecf0f1;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .nav-bar a {
            color: #3498db;
            text-decoration: none;
            font-weight: 500;
        }
        
        .nav-bar a:hover {
            text-decoration: underline;
        }
        
        .math-block {
            background-color: #f8f9fa;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #3498db;
            overflow-x: auto;
        }
        
        .definition {
            background-color: #e8f4fd;
            padding: 20px;
            margin: 20px 0;
            border-left: 4px solid #2196F3;
            border-radius: 4px;
        }
        
        .definition-title {
            font-weight: bold;
            color: #1976D2;
            margin-bottom: 10px;
        }
        
        .exercise {
            background-color: #fff3cd;
            padding: 20px;
            margin: 30px 0;
            border-left: 4px solid #ffc107;
            border-radius: 4px;
        }
        
        .exercise-title {
            font-weight: bold;
            color: #856404;
            margin-bottom: 10px;
        }
        
        .answer {
            background-color: #d4edda;
            padding: 15px;
            margin-top: 15px;
            border-radius: 4px;
            display: none;
        }
        
        .answer-toggle {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            margin-top: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.9em;
        }
        
        .answer-toggle:hover {
            background-color: #218838;
        }
        
        .code-block {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }
        
        .visualization {
            background-color: #f8f9fa;
            padding: 30px;
            margin: 20px 0;
            border-radius: 8px;
            text-align: center;
        }
        
        .figure-caption {
            color: #666;
            font-size: 0.9em;
            margin-top: 10px;
            font-style: italic;
        }
        
        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }
        
        li {
            margin-bottom: 8px;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 2em;
            }
            
            .nav-bar {
                flex-direction: column;
                gap: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="nav-bar">
            <a href="index.html">← 返回目录</a>
            <span>第1章 / 共14章</span>
            <a href="chapter2.html">下一章 →</a>
        </div>
        
        <h1>第1章：扩散模型导论</h1>
        
        <h2>1.1 什么是扩散模型？</h2>
        
        <p>扩散模型（Diffusion Models）是一类强大的生成模型，它通过学习数据的逐步去噪过程来生成高质量的样本。这个过程可以类比为物理学中的扩散现象：就像墨水在水中逐渐扩散直至均匀分布，扩散模型将数据逐步添加噪声直至变成纯噪声，然后学习如何反转这个过程。</p>
        
        <div class="definition">
            <div class="definition-title">定义 1.1（扩散模型）</div>
            扩散模型是一类概率生成模型，它定义了两个过程：
            <ul>
                <li><strong>前向过程（Forward Process）</strong>：将数据逐步添加噪声，最终变成纯高斯噪声</li>
                <li><strong>反向过程（Reverse Process）</strong>：从纯噪声开始，逐步去噪恢复出数据</li>
            </ul>
        </div>
        
        <h2>1.2 扩散模型的数学基础</h2>
        
        <h3>1.2.1 前向扩散过程</h3>
        
        <p>给定数据点 \(\mathbf{x}_0 \sim q(\mathbf{x}_0)\)，前向过程通过 \(T\) 步逐渐添加高斯噪声：</p>
        
        <div class="math-block">
            $$q(\mathbf{x}_t | \mathbf{x}_{t-1}) = \mathcal{N}(\mathbf{x}_t; \sqrt{1-\beta_t}\mathbf{x}_{t-1}, \beta_t\mathbf{I})$$
        </div>
        
        <p>其中 \(\beta_t\) 是第 \(t\) 步的噪声调度（noise schedule），控制每一步添加噪声的量。通过重参数化技巧，我们可以直接从 \(\mathbf{x}_0\) 采样任意时刻 \(t\) 的 \(\mathbf{x}_t\)：</p>
        
        <div class="math-block">
            $$q(\mathbf{x}_t | \mathbf{x}_0) = \mathcal{N}(\mathbf{x}_t; \sqrt{\bar{\alpha}_t}\mathbf{x}_0, (1-\bar{\alpha}_t)\mathbf{I})$$
        </div>
        
        <p>其中 \(\alpha_t = 1 - \beta_t\)，\(\bar{\alpha}_t = \prod_{s=1}^{t}\alpha_s\)。</p>
        
        <div class="exercise">
            <div class="exercise-title">练习 1.1：理解噪声调度</div>
            <p>假设我们有一个线性噪声调度：\(\beta_t = \frac{t}{T} \cdot 0.02\)，其中 \(T=1000\)。</p>
            <ol>
                <li>计算 \(t=100\) 时的 \(\bar{\alpha}_{100}\)</li>
                <li>当 \(t \to T\) 时，\(\mathbf{x}_t\) 的分布趋向于什么？</li>
            </ol>
            <button class="answer-toggle" onclick="toggleAnswer('answer1')">显示答案</button>
            <div id="answer1" class="answer">
                <p><strong>解答：</strong></p>
                <ol>
                    <li>首先计算 \(\beta_{100} = \frac{100}{1000} \times 0.02 = 0.002\)</li>
                    <li>因此 \(\alpha_{100} = 1 - 0.002 = 0.998\)</li>
                    <li>\(\bar{\alpha}_{100} = \prod_{s=1}^{100}\alpha_s \approx 0.998^{100} \approx 0.819\)</li>
                    <li>当 \(t \to T\) 时，\(\bar{\alpha}_t \to 0\)，所以 \(q(\mathbf{x}_t | \mathbf{x}_0) \to \mathcal{N}(0, \mathbf{I})\)</li>
                </ol>
            </div>
        </div>
        
        <h3>1.2.2 反向去噪过程</h3>
        
        <p>反向过程的目标是学习条件分布 \(p_\theta(\mathbf{x}_{t-1} | \mathbf{x}_t)\)，使其能够逐步去除噪声。我们通常将其参数化为：</p>
        
        <div class="math-block">
            $$p_\theta(\mathbf{x}_{t-1} | \mathbf{x}_t) = \mathcal{N}(\mathbf{x}_{t-1}; \boldsymbol{\mu}_\theta(\mathbf{x}_t, t), \sigma_t^2\mathbf{I})$$
        </div>
        
        <h2>1.3 扩散模型的优势</h2>
        
        <ul>
            <li><strong>生成质量高</strong>：能够生成极其逼真的图像，在许多指标上超越GAN</li>
            <li><strong>训练稳定</strong>：不存在GAN的模式崩塌问题，训练过程稳定可靠</li>
            <li><strong>理论基础扎实</strong>：有严格的概率论基础，目标函数有明确的意义</li>
            <li><strong>灵活性强</strong>：易于扩展到条件生成、图像编辑等任务</li>
        </ul>
        
        <h2>1.4 实践：可视化扩散过程</h2>
        
        <p>让我们通过一个简单的例子来直观理解扩散过程。下面的代码展示了如何对一个2D高斯分布进行前向扩散：</p>
        
        <div class="code-block">
<pre>import numpy as np
import matplotlib.pyplot as plt

# 生成初始数据：2D高斯分布
np.random.seed(42)
x0 = np.random.randn(1000, 2) * 0.5 + np.array([2, 2])

# 定义噪声调度
T = 100
betas = np.linspace(0.001, 0.02, T)
alphas = 1 - betas
alphas_bar = np.cumprod(alphas)

# 可视化不同时间步的数据分布
fig, axes = plt.subplots(1, 5, figsize=(15, 3))
time_steps = [0, 25, 50, 75, 99]

for i, t in enumerate(time_steps):
    if t == 0:
        xt = x0
    else:
        # 前向扩散：x_t = sqrt(alpha_bar_t) * x_0 + sqrt(1 - alpha_bar_t) * epsilon
        epsilon = np.random.randn(*x0.shape)
        xt = np.sqrt(alphas_bar[t-1]) * x0 + np.sqrt(1 - alphas_bar[t-1]) * epsilon
    
    axes[i].scatter(xt[:, 0], xt[:, 1], alpha=0.5, s=10)
    axes[i].set_xlim(-4, 4)
    axes[i].set_ylim(-4, 4)
    axes[i].set_title(f't = {t}')
    axes[i].grid(True, alpha=0.3)

plt.tight_layout()
plt.show()</pre>
        </div>
        
        <div class="exercise">
            <div class="exercise-title">练习 1.2：实现简单的1D扩散</div>
            <p>实现一个1D扩散过程的完整前向和反向过程。给定初始数据为单点 \(x_0 = 5\)：</p>
            <ol>
                <li>实现前向扩散过程，记录每一步的值</li>
                <li>假设你知道真实的反向过程，实现去噪过程</li>
                <li>绘制前向和反向过程的轨迹</li>
            </ol>
            <button class="answer-toggle" onclick="toggleAnswer('answer2')">显示答案</button>
            <div id="answer2" class="answer">
                <p><strong>参考代码：</strong></p>
                <pre style="background-color: #f8f9fa; padding: 15px; border-radius: 4px;">
import numpy as np
import matplotlib.pyplot as plt

# 初始化
x0 = 5.0
T = 50
betas = np.linspace(0.01, 0.2, T)

# 前向过程
x_forward = [x0]
for t in range(T):
    noise = np.random.randn()
    x_next = np.sqrt(1 - betas[t]) * x_forward[-1] + np.sqrt(betas[t]) * noise
    x_forward.append(x_next)

# 反向过程（假设知道真实的去噪方向）
x_reverse = [x_forward[-1]]
for t in range(T-1, -1, -1):
    # 这里简化处理，实际需要学习
    predicted_x0 = x0  # 假设知道目标
    direction = (predicted_x0 - x_reverse[-1]) / (t + 1)
    x_reverse.append(x_reverse[-1] + direction * 0.1 + np.random.randn() * 0.01)

# 绘图
plt.figure(figsize=(10, 5))
plt.plot(x_forward, 'b-', label='Forward Process', alpha=0.7)
plt.plot(x_reverse, 'r-', label='Reverse Process', alpha=0.7)
plt.xlabel('Time Step')
plt.ylabel('Value')
plt.legend()
plt.grid(True, alpha=0.3)
plt.show()
                </pre>
            </div>
        </div>
        
        <h2>1.5 历史发展与里程碑</h2>
        
        <p>扩散模型的发展经历了几个重要阶段：</p>
        
        <ol>
            <li><strong>2015年</strong>：Sohl-Dickstein等人提出了基于非平衡热力学的深度无监督学习方法</li>
            <li><strong>2020年</strong>：Ho等人提出DDPM（Denoising Diffusion Probabilistic Models），简化了训练过程</li>
            <li><strong>2021年</strong>：Song等人提出DDIM，大幅加速了采样过程</li>
            <li><strong>2022年</strong>：Stable Diffusion的发布，使文本到图像生成达到了新高度</li>
        </ol>
        
        <h2>1.6 本章小结</h2>
        
        <p>在本章中，我们学习了：</p>
        <ul>
            <li>扩散模型的基本概念和直观理解</li>
            <li>前向扩散过程的数学表述</li>
            <li>反向去噪过程的基本思想</li>
            <li>扩散模型相比其他生成模型的优势</li>
            <li>通过代码实现加深对扩散过程的理解</li>
        </ul>
        
        <p>下一章我们将深入学习DDPM的具体实现细节，包括训练算法、损失函数推导和实际代码实现。</p>
        
        <div class="exercise">
            <div class="exercise-title">综合练习：比较不同噪声调度</div>
            <p>实现并比较三种不同的噪声调度策略：</p>
            <ol>
                <li>线性调度：\(\beta_t = \beta_{\text{start}} + \frac{t}{T}(\beta_{\text{end}} - \beta_{\text{start}})\)</li>
                <li>余弦调度：基于余弦函数的平滑调度</li>
                <li>二次调度：\(\beta_t = \beta_{\text{start}} + \left(\frac{t}{T}\right)^2(\beta_{\text{end}} - \beta_{\text{start}})\)</li>
            </ol>
            <p>绘制 \(\bar{\alpha}_t\) 随时间的变化曲线，并讨论它们的优缺点。</p>
            <button class="answer-toggle" onclick="toggleAnswer('answer3')">显示答案</button>
            <div id="answer3" class="answer">
                <p><strong>提示：</strong></p>
                <ul>
                    <li>线性调度简单直观，但可能在早期步骤添加噪声过快</li>
                    <li>余弦调度在中间阶段更平滑，有助于保留更多信息</li>
                    <li>二次调度在早期添加噪声较慢，后期加速</li>
                    <li>选择哪种调度取决于具体任务和数据特性</li>
                </ul>
            </div>
        </div>
    </div>
    
    <script>
        // KaTeX自动渲染
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: '$$', right: '$$', display: true},
                    {left: '$', right: '$', display: false},
                    {left: '\\(', right: '\\)', display: false},
                    {left: '\\[', right: '\\]', display: true}
                ],
                throwOnError: false
            });
        });
        
        // 答案折叠功能
        function toggleAnswer(answerId) {
            const answer = document.getElementById(answerId);
            const button = answer.previousElementSibling;
            
            if (answer.style.display === 'none' || answer.style.display === '') {
                answer.style.display = 'block';
                button.textContent = '隐藏答案';
            } else {
                answer.style.display = 'none';
                button.textContent = '显示答案';
            }
        }
    </script>
</body>
</html>